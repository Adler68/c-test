/**
********************************************************************************
* @file     git_test_module.c
* @author   Bachmann electronic GmbH
*
* @brief    This file contains all standard initialization-/deinitialization
*           routines which are required for a software module.
*           On starting the module, the system calls the function
*           git_test_Init() which spawns the function git_test_bTaskMain
*           as the communication task (b-Task).
*           If git_test_Init returns "successfully", the SMI call
*           SMI_PROC_ENDOFINIT is sent in a second stage which brings
*           the module to the state RUN.
*
*           Normally it is not necessary to change this file,
*           all application specific work is done in the file git_test_app.c.
*           Only the execution of module specific SMI calls (if used)
*           has to be added to git_test_Main.
*
********************************************************************************
* COPYRIGHT BY BACHMANN ELECTRONIC GmbH 2015
*******************************************************************************/

/* VxWorks includes */
#include <vxWorks.h>
#include <string.h>
#include <taskLib.h>
#include <sigLib.h>
#include <stdio.h>
#include <setjmp.h>
#include <sysLib.h>
#include <symLib.h>
#include <sysSymTbl.h>

/* MSys includes */
#include <mtypes.h>
#include <msys_e.h>
#include <log_e.h>
#include <smi_e.h>
#include <res_e.h>
#include <mod_e.h>
#include <svi_e.h>
#include <prof_e.h>

/* Project includes */
#include "git_test_e.h"
#include "git_test_int.h"
#include "../src-gen/git_test_direct.h"
#include "../src-gen/git_test_direct_int.h"
#include "../src-gen/git_test_pi_int.h"
#include "../src-gen/git_test_svi_int.h"


/* Defines for SMI server task */
#define SMI_SRV_PRIO        120         /* Priority (range 118 ... 127) */
#define SMI_SRV_STACKSIZE   10000       /* Stack size in bytes */

/* Variable definitions */
UINT32  git_test_ModState;            /* Module state */
SEM_ID  git_test_StateSema = 0;       /* Semaphore for halting tasks */

/* Global variables: data structure for mconfig parameters */
GIT_TEST_BASE_PARMS git_test_BaseParams;
SINT32  git_test_DebugMode;           /* Debug level of module */

SMI_ID *git_test_pSmiId;              /* Id of module-SMI */
UINT32  git_test_SviHandle = 0;       /* SVI server handle */
CHAR    git_test_ModuleInfoDesc[SMI_DESCLEN_A];
MLOCAL jmp_buf JumpEnv;          /* Jump Environment for 'longjmp' */

/* Functions to be called from outside this file */
SINT32  git_test_Init(MOD_CONF * pConf, MOD_LOAD * pLoad);

/* Functions to be called only from within this file */
MLOCAL SINT32 BaseInit(void);
MLOCAL void BaseDeinit(void);
MLOCAL void bTaskMain(void);
MLOCAL void RpcNull(SMI_MSG *pMsg);
MLOCAL void RpcReset(SMI_MSG *pMsg);
MLOCAL void RpcStop(SMI_MSG *pMsg);
MLOCAL void RpcRun(SMI_MSG *pMsg);
MLOCAL void RpcNewCfg(SMI_MSG *pMsg);
MLOCAL void RpcDeinit(SMI_MSG *pMsg);
MLOCAL void RpcSetDbg(SMI_MSG *pMsg);
MLOCAL void RpcGetInfo(SMI_MSG *pMsg);
MLOCAL void RpcGetMapInfoLst(SMI_MSG *pMsg);
MLOCAL void RpcEndOfInit(SMI_MSG *pMsg);
MLOCAL void PanicHandler(UINT32 PanicMode);

/* Function pointer for extended version of smi_receive and svi_MsgHandler */
MLOCAL FUNCPTR fpSmiReceive = NULL;
MLOCAL FUNCPTR fpSviMsgHandler = NULL;

/* The file git_test.ver will be generated by the C++ Developer tool */
CHAR    git_test_Version[M_VERSTRGLEN_A] = {
#include "../src-gen/git_test.ver"
};

/**
********************************************************************************
* @brief Entry point of the module.
*        Will be called after module loading as part of the module handler.
*        Initializes the interfaces to the environment
*        (SMI, SVI) so that they are ready to operate.
*
*        Further steps of initialization will be performed in RpcEndOfInit()
*        which will be called by SMI after the function git_test_Init()
*        has returned.
*
* @param[in]  pConf   Parameter for configuration (data from MCONFIG.INI).
* @param[in]  pLoad   Parameter from module loading.
*
* @retval     >= 0 .. Task-Id, module initialized correctly
* @retval      < 0 .. Error during initialization
*******************************************************************************/
SINT32 git_test_Init(MOD_CONF *pConf, MOD_LOAD *pLoad)
{
    const CHAR *pFunc = __func__;
    SINT32  TskId = ERROR;
    CHAR    TaskName[M_TSKNAMELEN_A];
    SYM_TYPE symType = 0;

    /* Get address of the global debug mode. Debug mode may be directly set from
     * command line or smi call. */
    git_test_BaseParams.pDebugMode = &git_test_DebugMode;

    /* Get the configuration from the module loader. (BaseParams) */
    *git_test_BaseParams.pDebugMode = pConf->DebugMode;
    git_test_BaseParams.CfgLineNbr = pConf->LineNbr;
    git_test_BaseParams.DefaultPriority = pConf->TskPrior;
    strcpy(git_test_BaseParams.AppName, pConf->AppName);
    strcpy(git_test_BaseParams.CfgFileName, pConf->ProfileName);

    /* Conditional info message */
    LOG_I(2,pFunc, "Initializing module '%s' of type '%s.m' in partition %d",
          pConf->AppName, pConf->TypeName, pConf->MemPart);

    /* to be left upon error */
    do
    {
        /*
         * Deliver module parameters to resource management.
         * The variable git_test_SmiId will be initialized by MOD.
         * This ID will be required as parameter to send and receive
         * SMI calls
         */
        if (res_ModParam(git_test_BaseParams.AppName, 2,
                         2, RES_UNLIMITUSR, &git_test_pSmiId) != RES_E_OK)
        {
            LOG_E(0, pFunc, "Could not register Module on MOD!");
            break;
        }

        (void)symFindByName(sysSymTbl, "_smi_Receive2", (char **)&fpSmiReceive, &symType);
        if (!fpSmiReceive)
        {
            LOG_E(0, pFunc, "Could not find smi_Receive2!");
            break;
        }

        (void)symFindByName(sysSymTbl, "_svi_MsgHandler2", (char **)&fpSviMsgHandler, &symType);
        if (!fpSviMsgHandler)
        {
            LOG_E(0, pFunc, "Could not find smi_MsgHandler2!");
            break;
        }

        /*
         * Base initialization of module
         * An error in this function does not abort initialization
         * but leads to the module state ERROR
         */
        if (BaseInit() < 0)
        {
            git_test_ModState = RES_S_ERROR;
        }
        else
        {
            git_test_ModState = RES_S_EOI;
        }

        /*
         * Start the SMI server as task for handling incoming SMI-calls.
         * This task should be in the priority group "Application 2"
         */
        sprintf(TaskName, "b%s", git_test_BaseParams.AppName);
        TskId = sys_TaskSpawn(git_test_BaseParams.AppName, TaskName, SMI_SRV_PRIO,
                              VX_FP_TASK, SMI_SRV_STACKSIZE, (FUNCPTR)bTaskMain);

        /* Test if task is successfully started */
        if (TskId == ERROR)
        {
            LOG_E(0, pFunc, "Error in sys_TaskSpawn;'%s'!", TaskName);
            break;
        }

        /*
         * After the values have been copied from pLoad, the memory can now be freed.
         * ATTENTION: In case of an error the module handler will free this memory.
         */
        if (pLoad->pCfg && pLoad->LenCfg)
        {
            sys_MemPFree(pConf->MemPart, pLoad->pCfg);
        }

        if (pLoad->pAttr && pLoad->LenAttr)
        {
            sys_MemPFree(pConf->MemPart, pLoad->pAttr);
        }

        /* Inform resource handler about changes of the module state */
        if (res_ModState(git_test_BaseParams.AppName, git_test_ModState) < 0)
        {
            LOG_E(0, pFunc, "Change of Software-Module-State failed!");
        }

        /* Success message */
        LOG_I(0, pFunc, "Initialized module '%s' of type '%s.m' in partition %d",
              pConf->AppName, pConf->TypeName, pConf->MemPart);

        /* Return Id of Task which will handle RPC-calls */
        return (TskId);

    }
    while (FALSE);

    /*
     * If processing reaches this point, there has been an error.
     * Free all resources which could have been allocated so far
     * and return an error.
     */
    LOG_E(0, pFunc, "Initialization error, cleaning up resources now");
    BaseDeinit();
    TskId = ERROR;

    return (TskId);
}

/**
********************************************************************************
* @brief Base initializations concerning the main task of the module
*        - reading configuration
*        - applying SVI
*        - start for module necessary tasks
*        - ...
*        Normally initialization routines of the adequate subranges of the
*        SW-module will be called.
*
* @retval    >= 0 .. OK
* @retval     < 0 .. ERROR
*******************************************************************************/
MLOCAL SINT32 BaseInit(void)
{
    const CHAR *pFunc = __func__;
    SINT32  ret = 0;

    /* create semaphore for halting all tasks in STOP state of module */
    if (!(git_test_StateSema = semBCreate(SEM_Q_PRIORITY, SEM_EMPTY)))
    {
        LOG_E(0, pFunc, "Could not create semaphore for stop state!");
        return (ERROR);
    }

    /*
     * Read configuration.
     * The SVI of the module can depend on the configuration,
     * so the configuration is read before the SVI server init is being called.
     */
    ret = git_test_CfgRead();
    if (ret < 0)
    {
        return (ret);
    }

    /* Initialize SVI server */
    ret = git_test_sviServer_init();
    if (ret < 0)
    {
        return (ret);
    }

    /* Initialize SVI server for process image variables */
    ret = git_test_pi_sviServerInit();
    if (ret < 0)
    {
        return (ret);
    }

    /* Initialize SVI server for direct variables */
    ret = git_test_direct_sviServerInit();
    if (ret < 0)
    {
        return (ret);
    }

    return (ret);
}

/**
********************************************************************************
* @brief Frees all module resources
*        Complement to BaseInit(), resources are free'd in reverse order.
*******************************************************************************/
MLOCAL void BaseDeinit(void)
{
    SINT32  ret;
    static const CHAR *pFunc = __FUNCTION__;

    /* Inform resource handler about changes of the module state */
    ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_DEINIT);
    if (ret != RES_E_OK)
    {
        LOG_E(0, pFunc, "Change of Software-Module-State to DEINIT failed!");
    }

    /* Delete semaphore for halting all tasks in STOP state of module */
    if (git_test_StateSema)
    {
        if (semDelete(git_test_StateSema) < 0)
        {
            LOG_E(0, pFunc, "Could not delete state semaphore!");
        }
        else
        {
            git_test_StateSema = 0;
        }
    }

    /*
     * Prevent external SVI-clients from accessing the module
     * before the exported resources are being deleted
     */
    git_test_sviServer_deinit();

    /* De-initialize resources allocated in git_test_AppInit() */
    git_test_AppDeinit();

}

/**
********************************************************************************
* @brief Started as communication task when the SW-module is loaded
*        Handles incoming SMI-calls in an endless loop.
*        Contains the entry point for the optional restart after an
*        exception (ExecpitonSignal) and for
*        optional shutdown sequences. (PanicSignal)
*******************************************************************************/
MLOCAL void bTaskMain(void)
{
    SINT32  Status;
    SMI_MSG Msg;
    SINT32  ret;
    UINT32  UserSessionId = 0;          /* Session Id for checking user rights */
    static const CHAR *pFunc = __FUNCTION__;

    LOG_I(2, pFunc, "Starting communication task");

    /*
     * The function setjmp() acts as entry point after exceptions.
     * This is necessary if you want to restart you application
     * after an exception.
     */
    Status = setjmp(JumpEnv);
    if (Status == 0)
    {
        /* This branch will be taken after start of GIT_TEST */

        /* Install signal handler for power-down */
        if (sys_PanicSigSet(PanicHandler) < 0)
        {
            LOG_E(0, pFunc, "Panic signal handler could not be installed!");
        }
    }
    else
    {
        /* This branch will be taken after longjmp() (after an exception) */
        LOG_I(2, pFunc, "Task restarted on signal %d.", Status);

        /* Cleanup after an exception */
        BaseDeinit();

        /* Make base initialization of module (after an exception) */
        if (BaseInit() < 0)
        {
            ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_ERROR);
            if (ret != RES_E_OK)
            {
                LOG_E(0, pFunc, "Change of Software-Module-State to EOI failed!");
            }
        }
        else
        {
            /* Module is now running correctly */
            ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_RUN);
            if (ret != RES_E_OK)
            {
                LOG_E(0, pFunc, "Change of Software-Module-State to RUN failed!");
            }
        }
    }

    /*
     * Initialization of SMI task is finished, the following endless loop
     * is executed endlessly as task for handling incoming SMI calls.
     * The task is suspended by the OS on calling the function smi_Receive().
     * smi_Receive can either WAIT_FOREVER (sleep until SMI call comes in),
     * or it can resume after the given timeout.
     * The timeout in smi_Receive() is only required if the software module
     * expects replies of other modules to own requests,
     * and these replies have to be checked for timeout.
     */
    while (1)
    {
        /*
         * Inform the system that the cycle ends.
         * This if for cycle time statistics,
         * values can be seen in the task view of the Device Manager.
         */
        sys_CycleEnd();

        /* Wait for SMI message in receive buffer */
        Status = fpSmiReceive(git_test_pSmiId, &Msg, WAIT_FOREVER, &UserSessionId);

        /* Inform the system that the cycle starts */
        sys_CycleStart();

        /* Test if SMI message has been received */
        if (Status != 0)
        {
            continue;
        }

        if (Msg.Type & SMI_F_CALL)
        {
            switch (Msg.ProcRetCode)
            {
                case SMI_PROC_NULL:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_NULL", pFunc);
                    RpcNull(&Msg);
                    break;

                case SMI_PROC_DEINIT:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_DEINIT", pFunc);
                    RpcDeinit(&Msg);
                    return;             /* quit task completely in this case */

                case SMI_PROC_RESET:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_RESET", pFunc);
                    RpcReset(&Msg);
                    break;

                case SMI_PROC_STOP:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_STOP", pFunc);
                    RpcStop(&Msg);
                    break;

                case SMI_PROC_RUN:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_RUN", pFunc);
                    RpcRun(&Msg);
                    break;

                case SMI_PROC_NEWCFG:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_NEWCFG", pFunc);
                    RpcNewCfg(&Msg);
                    break;

                case SMI_PROC_GETINFO:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_GETINFO", pFunc);
                    RpcGetInfo(&Msg);
                    break;

                case SMI_PROC_MAPPINGINFOLST:
                   LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_MAPPINGINFOLST", pFunc);
                   RpcGetMapInfoLst(&Msg);
                   break;

                case SMI_PROC_ENDOFINIT:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_ENDOFINIT", pFunc);
                    RpcEndOfInit(&Msg);
                    break;

                case SMI_PROC_SETDBG:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SMI_PROC_SETDBG", pFunc);
                    RpcSetDbg(&Msg);
                    break;

                    /*
                     * All SVI access operations that are required in SMI calls
                     * will be handled by the SVI handler.
                     */

                    /* for information on server and variable properties */
                case SVI_PROC_GETADDR:
                case SVI_PROC_GETPVINF:
                case SVI_PROC_GETSERVINF:
                    /* mainly used for list access access by SC and HMI */
                case SVI_PROC_GETVALLST:
                case SVI_PROC_SETVALLST:
                    /* mainly used by other applications for single access */
                case SVI_PROC_GETVAL:
                case SVI_PROC_SETVAL:
                case SVI_PROC_GETBLK:
                case SVI_PROC_SETBLK:
                case SVI_PROC_GETMULTIBLK:
                case SVI_PROC_SETMULTIBLK:
                    LOG_I(4, git_test_BaseParams.AppName, "%s: received call SVI_PROC_....", pFunc);
                    /* Pass call to message handler */
                    (void)fpSviMsgHandler(git_test_SviHandle, &Msg, git_test_pSmiId, UserSessionId);
                    break;

                    /* Not a standard SMI call */
                default:
                    /* pass the message to the application SMI server */
                    ret = git_test_AppSmiSvr(&Msg, UserSessionId);

                    /* If application SMI server has accepted the call */
                    if (ret == OK)
                    {
                        break;
                    }

                    LOG_W(2, git_test_BaseParams.AppName, "%s: received unknown call with SMI id %d", pFunc, Msg.ProcRetCode);

                    smi_FreeData(&Msg);

                    if (smi_SendReply(git_test_pSmiId, &Msg, SMI_E_PROC, 0, 0) < 0)
                    {
                        LOG_E(0, pFunc, "User defined smi_SendReply failed!");
                    }
            }
        }

        smi_FreeData(&Msg);
    }
}

/**
********************************************************************************
* @brief Handles the RPC-request SMI_PROC_NULL.
*
* @param[in]  pMsg    RPC--request
*******************************************************************************/
MLOCAL void RpcNull(SMI_MSG *pMsg)
{
    smi_FreeData(pMsg);
    if (smi_SendReply(git_test_pSmiId, pMsg, SMI_E_OK, 0, 0) < 0)
    {
        LOG_E(0, "RpcNull", "Case SMI_PROC_NULL - SMI SendReply failed!");
    }
}

/**
********************************************************************************
* @brief Resets the module to the same state as after template_Init()
*
*        All module specific resources were freed and new allocated.
*
* @param[in]  pMsg    SMI call
*******************************************************************************/
MLOCAL void RpcReset(SMI_MSG *pMsg)
{
    SMI_RESET_R Reply;
    SINT32  ret;
    Reply.RetCode = SMI_E_OK;

    /* Freeing application specific resources */
    BaseDeinit();

    /* Make base initialization of module */
    if (BaseInit() < 0)
    {
        /* Set module state to ERROR */
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_ERROR);
        if (ret != RES_E_OK)
        {
            LOG_E(0, "RpcReset", "Change of Software-Module-State to ERROR failed!");
        }

        Reply.RetCode = SMI_E_FAILED;
    }
    else
    {
        /* Set module state to "End Of Init" */
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_EOI);
        if (ret != RES_E_OK)
        {
            LOG_E(0, "RpcReset", "Change of Software-Module-State to EOI failed!");
        }

        Reply.RetCode = SMI_E_OK;
    }

    /* Send reply */
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, "RpcReset", "SMI SendCReply failed!");
    }
}

/**
********************************************************************************
* @brief Sets the module from RUN to STOP state.
*        In this state only a few RPC's are accepted.
*
*        All additional tasks (beside git_test_main()) have to implement the
*        following lines in order to stop the whole module:
*
*            if (git_test_ModState != RES_S_RUN)
*                semTake(git_test_StateSema, WAIT_FOREVER);
*
* @param[in]  pMsg    RPC-request
*******************************************************************************/
MLOCAL void RpcStop(SMI_MSG *pMsg)
{
    SMI_STOP_R Reply;
    SINT32  ret;

    if (git_test_ModState != RES_S_RUN)
    {
        Reply.RetCode = SMI_E_FAILED;
    }
    else
    {
        /* Set module state */
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_STOP);
        if (ret != RES_E_OK)
        {
            LOG_E(0, "RpcStop", "Change of Software-Module-State to STOP failed!");
        }

        Reply.RetCode = SMI_E_OK;
    }

    /* Send reply */
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, "RpcStop", "SMI SendCReply failed!");
    }
}

/**
********************************************************************************
* @brief Changes module state from STOP to RUN
*
* @param[in]  pMsg    RPC-request
*******************************************************************************/
MLOCAL void RpcRun(SMI_MSG *pMsg)
{
    SMI_RUN_R Reply;
    SINT32  ret;

    if (git_test_ModState != RES_S_STOP)
    {
        LOG_E(0, "RpcRun", "Module is not in STOP state!");
        Reply.RetCode = SMI_E_FAILED;
    }
    else
    {
        /* Set module state to RUN */
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_RUN);
        if (ret != RES_E_OK)
        {
            LOG_E(0, "RpcRun", "Change of Software-Module-State to RUN failed!");
        }

        /* Restart all stopped tasks of the module which are waiting in semTake() */
        (void)semFlush(git_test_StateSema);

        Reply.RetCode = SMI_E_OK;
    }

    /* Send reply */
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, "RpcRun", "SMI SendCReply failed!");
    }
}

/**
********************************************************************************
* @brief Reloads the module configuration.
*
* @param[in]  pMsg    SMI call
*******************************************************************************/
MLOCAL void RpcNewCfg(SMI_MSG *pMsg)
{
    SMI_NEWCFG_R Reply;
    SINT32  ret;

    /* Test if module is in a valid state to take over a new configuration */
    if (git_test_ModState == RES_S_STOP || git_test_ModState == RES_S_RUN ||
        git_test_ModState == RES_S_ERROR)
    {
        /* Remove application (if it is running) */
        git_test_AppDeinit();

        /* Restart application with the new configuration */
        if (git_test_CfgRead() || git_test_AppEOI())
        {
            ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_ERROR);
            if (ret != RES_E_OK)
            {
                LOG_E(0, "RpcNewCfg", "Change of Software-Module-State to ERROR failed!");
            }

            Reply.RetCode = SMI_E_FAILED;
        }
        else
        {
            /* Set module state OK */
            ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_EOI);
            if (ret != RES_E_OK)
            {
                LOG_E(0, "RpcNewCfg", "Change of Software-Module-State to EOI failed!");
            }

            Reply.RetCode = SMI_E_OK;
        }
    }
    else
        Reply.RetCode = SMI_E_FAILED;

    /* Send reply */
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, "RpcNewCfg", "SMI SendCReply failed!");
    }
}

/**
********************************************************************************
* @brief Handles the RPC-call SMI_PROC_DEINIT.
*        This RPC-call causes the module to delete itself.
*
* @param[in]  pMsg    SMI call
*******************************************************************************/
MLOCAL void RpcDeinit(SMI_MSG *pMsg)
{
    SMI_DEINIT_R Reply;

    /*
     * First the reply-message has to be sent back,
     * because git_test_SmiId will become invalid
     * after calling res_ModDelete().
     */
    Reply.RetCode = SMI_E_OK;
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, "RpcDeinit", "SMI SendCReply failed!");
    }

    /* Freeing application specific resources */
    BaseDeinit();

    /* Logout from the resource handler */
    if (res_ModDelete(git_test_BaseParams.AppName) != RES_E_OK)
    {
        LOG_E(0, "RpcDeinit", "Delete of module resource failed!");
    }

    /* De-install signal handlers */
    if (sys_PanicSigReset() < 0)
    {
        LOG_E(0, "RpcDeinit", "Panic signal handler could not be deleted!",
              git_test_BaseParams.AppName);
    }

    if (sys_ExcSigReset() < 0)
    {
        LOG_E(0, "RpcDeinit", "Exception signal handler could not be deleted!");
    }

    LOG_I(1, "RpcDeinit", "Module has been deleted");
}

/**
********************************************************************************
* @brief Handles the SMI call SMI_PROC_ENDOFINIT.
*        This call causes the module to make all initializations which
*        are required by the module and sets it to the state RUN.
*
*        A operational system requires that all SW-modules are started and
*        had initialized there environment interfaces.
*
* @param[in]  pMsg    SMI call
*******************************************************************************/
MLOCAL void RpcEndOfInit(SMI_MSG *pMsg)
{
    SMI_ENDOFINIT_R Reply;
    SINT32  ret;
    static const CHAR *pFunc = __FUNCTION__;

    Reply.RetCode = SMI_E_OK;

    if (git_test_ModState != RES_S_EOI)
    {
        LOG_E(0, pFunc, "Module is not in end of init state!");

        /* Wrong module state for "End of Init" */
        Reply.RetCode = SMI_E_FAILED;

        /* Send reply and return */
        smi_FreeData(pMsg);
        if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
        {
            LOG_E(0, pFunc, "SMI SendCReply failed!");
        }

        return;
    }

    /* Installing my application task */
    if (git_test_AppEOI() < 0)
    {
        Reply.RetCode = SMI_E_FAILED;
    }
    else
    {
        /* Module is now running correctly */
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_RUN);

        if (ret)
        {
            LOG_E(0, pFunc, "Change of Software-Module-State to RUN failed!");
            Reply.RetCode = SMI_E_FAILED;
        }
        else
        {
            /* Restart all stopped tasks of the module which are waiting in semTake() */
            (void)semFlush(git_test_StateSema);

            LOG_I(1, pFunc, "Module successfully started.");
        }
    }

    if (Reply.RetCode == SMI_E_FAILED)
    {
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_ERROR);
        if (ret != RES_E_OK)
        {
            LOG_E(0, pFunc, "Change of module state to ERROR failed!");
        }
    }
    else
    {
        ret = res_ModState(git_test_BaseParams.AppName, git_test_ModState = RES_S_RUN);
        if (ret != RES_E_OK)
        {
            LOG_E(0, pFunc, "Change of module state to RUN failed!");
        }
    }

    /* Send reply */
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, pFunc, "SMI SendCReply failed!");
    }
}

/**
********************************************************************************
* @brief Handles the RPC-request SMI_PROC_SETDBG.
*        This RPC-call causes the module to set the debug mode.
*
* @param[in]  pMsg    RPC-request
*******************************************************************************/
MLOCAL void RpcSetDbg(SMI_MSG *pMsg)
{
    SMI_SETDBG_C *pCall;
    SMI_SETDBG_R Reply;

    pCall = (SMI_SETDBG_C *)pMsg->Data;

    /* Take over the new debug mode */
    git_test_DebugMode = pCall->DebugMode;
    Reply.RetCode = SMI_E_OK;

    /* Send reply */
    smi_FreeData(pMsg);
    if (smi_SendCReply(git_test_pSmiId, pMsg, SMI_E_OK, &Reply, sizeof(Reply)) < 0)
    {
        LOG_E(0, "RpcSetDbg", "SMI SendCReply failed!");
    }
}

/**
********************************************************************************
* @brief Handles the RPC-request SMI_PROC_GETINFO.
*
* @param[in]  pMsg    RPC-request
*******************************************************************************/
MLOCAL void RpcGetInfo(SMI_MSG *pMsg)
{
    SMI_GETINFO_R *pReply;
    SYS_VERSION Version;

    smi_FreeData(pMsg);

    /* Allocate memory for the answer */
    pReply = smi_MemAlloc(sizeof(*pReply));
    if (!pReply)
    {
        LOG_E(0, "RpcGetInfo", "No memory!");
        if (smi_SendReply(git_test_pSmiId, pMsg, SMI_E_ARGS, 0, 0) < 0)
        {
            LOG_E(0, "RpcGetInfo", "SendReply failed!");
        }

        return;
    }

    /* Deposit module name and description */
    strncpy(pReply->Name, git_test_BaseParams.AppName, M_MODNAMELEN);
    pReply->Name[M_MODNAMELEN] = 0;

    strncpy(pReply->Desc, git_test_ModuleInfoDesc, sizeof(pReply->Desc));
    pReply->Desc[sizeof(pReply->Desc) - 1] = 0;

    /*
     * Convert the version string to an integer
     * CONSIDERATION:   The version string has the following format
     *                  "Vaa.bb.cc ddd"  whereas cc is optional
     *                  Example: "V1.02.03 Alpha", "V2.12 Beta",
     *                           "V5.01 Release" or "V5.01"
     * In this case, the msys function sys_GetVersion() can be used.
     */
    sys_GetVersion(&Version, git_test_Version);
    pReply->VersType = Version.Type;
    memcpy(pReply->VersCode, Version.Code, sizeof(pReply->VersCode));

    pReply->State = git_test_ModState;
    pReply->DebugMode = git_test_DebugMode;
    pReply->RetCode = SMI_E_OK;

    /* Send reply */
    if (smi_SendReply(git_test_pSmiId, pMsg, SMI_E_OK, pReply, sizeof(*pReply)) < 0)
    {
        LOG_E(0, "RpcGetInfo", "SendReply of module information (Ping) failed!");
    }
}

/**
********************************************************************************
* @brief Handles the RPC-request SMI_PROC_MAPPINGINFOLST.
*
* @param[in]  pMsg    RPC-request
*******************************************************************************/
MLOCAL void RpcGetMapInfoLst(SMI_MSG *pMsg)
{
    SMI_GETMAPINFOLST_R *pReply;
    UINT32 NbOfPiInCh  = git_test_pi_getNbOfInChans();
    UINT32 NbOfPiOutCh = git_test_pi_getNbOfOutChans();
    UINT32 NbOfDirectInCh  = git_test_direct_getNbOfInChans();
    UINT32 NbOfDirectOutCh = git_test_direct_getNbOfOutChans();
    UINT32 ReplyLen        = 0;
    UINT32 ChCount         = 0;
    UINT32 i               = 0;
    CHAR *pPiInVarNames[NbOfPiInCh];
    CHAR *pPiInMapNames[NbOfPiInCh];
    CHAR *pPiOutVarNames[NbOfPiOutCh];
    CHAR *pPiOutMapNames[NbOfPiOutCh];
    CHAR *pDirectInVarNames[NbOfDirectInCh];
    CHAR *pDirectInMapNames[NbOfDirectInCh];
    CHAR *pDirectOutVarNames[NbOfDirectOutCh];
    CHAR *pDirectOutMapNames[NbOfDirectOutCh];
    SINT32 *pPiInStatus[NbOfPiInCh];
    SINT32 *pPiOutStatus[NbOfPiOutCh];
    SINT32 *pDirectInStatus[NbOfDirectInCh];
    SINT32 *pDirectOutStatus[NbOfDirectOutCh];


    smi_FreeData(pMsg);

    /* Get mapping info of pi variables */
    (void)git_test_pi_getMapInfo(pPiInVarNames, pPiInMapNames,
                                pPiOutVarNames, pPiOutMapNames,
                                pPiInStatus, pPiOutStatus);

    /* Get mapping info of direct variables */
    (void)git_test_direct_getMapInfo(pDirectInVarNames, pDirectInMapNames,
                                pDirectOutVarNames, pDirectOutMapNames,
                                pDirectInStatus, pDirectOutStatus);

    /* Calculate length of reply message. */
    ReplyLen = sizeof(*pReply) - (sizeof(SMI_COMPCHINFO)) +
               (NbOfPiInCh + NbOfDirectInCh + NbOfPiOutCh + NbOfDirectOutCh) * sizeof(SMI_COMPCHINFO);

    /* Allocate memory for the answer */
    pReply = smi_MemAlloc((UINT32)ReplyLen);
    if (!pReply)
    {
        LOG_E(0, "RpcGetMapInfoLst", "No memory!");
        if (smi_SendReply(git_test_pSmiId, pMsg, SMI_E_ARGS, 0, 0) < 0)
        {
            LOG_E(0, "RpcGetMapInfoLst", "SendReply failed!");
        }
        return;
    }

    /* Write reply message */
    for (i = 0; i < NbOfPiInCh; i++)
    {
        strncpy(pReply->ChLst[ChCount].CompVarName, pPiInVarNames[i], SVI_ADDRLEN);
        strncpy(pReply->ChLst[ChCount].MapVarName, pPiInMapNames[i], SVI_ADDRLEN);
        pReply->ChLst[ChCount].Type = InChan;
        pReply->ChLst[ChCount].State = *pPiInStatus[i];
        ChCount++;

        /* Free variables */
        sys_MemFree(pPiInVarNames[i]);
        sys_MemFree(pPiInMapNames[i]);
        sys_MemFree(pPiInStatus[i]);
    }

    for (i = 0; i < NbOfDirectInCh; i++)
    {
        strncpy(pReply->ChLst[ChCount].CompVarName, pDirectInVarNames[i], SVI_ADDRLEN);
        strncpy(pReply->ChLst[ChCount].MapVarName, pDirectInMapNames[i], SVI_ADDRLEN);
        pReply->ChLst[ChCount].Type = InChan;
        pReply->ChLst[ChCount].State = *pDirectInStatus[i];
        ChCount++;

        /* Free variables */
        sys_MemFree(pDirectInVarNames[i]);
        sys_MemFree(pDirectInMapNames[i]);
        sys_MemFree(pDirectInStatus[i]);
    }

    for (i = 0; i < NbOfPiOutCh; i++)
    {
        strncpy(pReply->ChLst[ChCount].CompVarName, pPiOutVarNames[i], SVI_ADDRLEN);
        strncpy(pReply->ChLst[ChCount].MapVarName, pPiOutMapNames[i], SVI_ADDRLEN);
        pReply->ChLst[ChCount].Type = OutChan;
        pReply->ChLst[ChCount].State = *pPiOutStatus[i];
        ChCount++;

        /* Free variables */
        sys_MemFree(pPiOutVarNames[i]);
        sys_MemFree(pPiOutMapNames[i]);
        sys_MemFree(pPiOutStatus[i]);
    }

    for (i = 0; i < NbOfDirectOutCh; i++)
    {
        strncpy(pReply->ChLst[ChCount].CompVarName, pDirectOutVarNames[i], SVI_ADDRLEN);
        strncpy(pReply->ChLst[ChCount].MapVarName, pDirectOutMapNames[i], SVI_ADDRLEN);
        pReply->ChLst[ChCount].Type = OutChan;
        pReply->ChLst[ChCount].State = *pDirectOutStatus[i];
        ChCount++;

        /* Free variables */
        sys_MemFree(pDirectOutVarNames[i]);
        sys_MemFree(pDirectOutMapNames[i]);
        sys_MemFree(pDirectOutStatus[i]);
    }

    pReply->NbOfInCh  = NbOfPiInCh + NbOfDirectInCh;
    pReply->NbOfOutCh = NbOfPiOutCh + NbOfDirectOutCh;
    pReply->RetCode = SMI_E_OK;


    if (smi_SendReply(git_test_pSmiId, pMsg, SMI_E_OK, pReply, ReplyLen) < 0)
    {
        LOG_E(0, "RpcGetInfo", "SendReply of module information (Ping) failed!");
    }
}

/**
********************************************************************************
* @brief Handler for panic-situation.
*
* @param[in]  PanicMode       Type of panic-situation (SYS_APPPANIC, ...)
*******************************************************************************/
MLOCAL void PanicHandler(UINT32 PanicMode)
{
    /*
     * TODO:
     * Bring critical parts to a predefined state.
     * For example save data to NV-RAM or close open files.
     */
}
